/*
QRZ Logbook API

This API provides methods for external programs to interact with the QRZ Logbook using an HTTP REST interface. The QRZ Logbook is a combination free and paid subscription service of QRZ. Some advanced features require a valid subscription while the majority of operations are free to all QRZ members. All users of the QRZ Logbook, regardless of their subscription status, may access, edit, update, and view their complete logs online at the QRZ website.

API version: 1.0.0
Contact: flloyd@qrz.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package qrzlog

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiRootPostRequest struct {
	ctx        context.Context
	ApiService *DefaultAPIService
	kEY        *string
	aCTION     *string
	aDIF       *string
	oPTION     *string
	lOGIDS     *string
}

// A QRZ supplied logbook access key
func (r ApiRootPostRequest) KEY(kEY string) ApiRootPostRequest {
	r.kEY = &kEY
	return r
}

// Type of request, i.e. INSERT, DELETE, UPLOAD, etc.
func (r ApiRootPostRequest) ACTION(aCTION string) ApiRootPostRequest {
	r.aCTION = &aCTION
	return r
}

// ADIF formatted input data
func (r ApiRootPostRequest) ADIF(aDIF string) ApiRootPostRequest {
	r.aDIF = &aDIF
	return r
}

// Action-specific options
func (r ApiRootPostRequest) OPTION(oPTION string) ApiRootPostRequest {
	r.oPTION = &oPTION
	return r
}

// A comma separated list of integer logid values
func (r ApiRootPostRequest) LOGIDS(lOGIDS string) ApiRootPostRequest {
	r.lOGIDS = &lOGIDS
	return r
}

func (r ApiRootPostRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.RootPostExecute(r)
}

/*
RootPost The do-everything endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRootPostRequest
*/
func (a *DefaultAPIService) RootPost(ctx context.Context) ApiRootPostRequest {
	return ApiRootPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Response
func (a *DefaultAPIService) RootPostExecute(r ApiRootPostRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RootPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kEY == nil {
		return localVarReturnValue, nil, reportError("kEY is required and must be specified")
	}
	if r.aCTION == nil {
		return localVarReturnValue, nil, reportError("aCTION is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-www-form-urlencoded"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "KEY", r.kEY, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ACTION", r.aCTION, "", "")
	if r.aDIF != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ADIF", r.aDIF, "", "")
	}
	if r.oPTION != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "OPTION", r.oPTION, "", "")
	}
	if r.lOGIDS != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "LOGIDS", r.lOGIDS, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
